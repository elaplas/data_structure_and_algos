
#include <iostream>
#include <vector>
#include "allocator.h"


// Difference between malloc and new
// malloc: allocate memory without calling constructors (allocation without construction)
// malloc: output of malloc() is a void pointer which should be explicitly casted to corresponding pointer
// new: allocate memory and calling constructors (allocation and construction)

// Difference between free and delete
// free: deallocate memory without calling destructors (deallocation without destruction)
// delete: deallocate memory and calling destructors (deallocation and destruction)


// Allocation from data memory
unsigned char dataMemPtr[8];

int main()
{
   // Construction of objects in data memory
   auto objPtrOnData1 = new((void*)dataMemPtr) int(5);
   auto objPtrOnData2 = new((void*)dataMemPtr+4) int(6);

   // Allocation from stack memory
   unsigned char stackMemPtr[8];

   // Construction of objects in stack memory
   auto objPtrOnStack1 = new((void*)stackMemPtr) int(5);
   auto objPtrOnStack2 = new((void*)stackMemPtr+4) int(6);

   // Allocation from heap memory
   auto heapMemPtr = new unsigned char[10];

   // Construction of objects in heap memory
   auto objPtrOnHeap1 = new((void*)heapMemPtr) int(5);
   auto objPtrOnHeap2 = new((void*)heapMemPtr+4) int(6);


   // It exceeds the allocated data memory but no error or warning is generated by compiler but it is of course dangerous 
   auto objPtrOnData3 = new((void*)dataMemPtr+8) int(7);
   // It leads to the error "stack smashing detected" because it exceeds the allocated stack memory and causes "buffer overflow", which can 
   // overwrite the return address of main function  
   auto objPtrOnStack3 = new((void*)stackMemPtr+8) int(7);
   // It exceeds the allocated heap memory but no error or warning is generated by compiler but it is of course dangerous 
   auto objPtrOnHeap3 = new((void*)dataMemPtr+8) int(7);


   std::cout<<"........data memory........."<<std::endl;

   std::cout<<*objPtrOnData1<<std::endl;
   std::cout<<*objPtrOnData2<<std::endl;
   std::cout<<*objPtrOnData3<<std::endl;

   std::cout<<"........stack memory........."<<std::endl;

   std::cout<<*objPtrOnStack1<<std::endl;
   std::cout<<*objPtrOnStack2<<std::endl;
   std::cout<<*objPtrOnStack3<<std::endl;

   std::cout<<"........heap memory........."<<std::endl;

   std::cout<<*objPtrOnHeap1<<std::endl;
   std::cout<<*objPtrOnHeap2<<std::endl;
   std::cout<<*objPtrOnHeap3<<std::endl;

    std::cout<<"........vector with custom memory allocation........."<<std::endl;

   // Use a custom allocator for allocation and deallocation of std::vector
   std::vector<int, allocator<int>> vec;
   vec.push_back(30);
   vec.push_back(40);
   vec.push_back(50);
   

   return 0;
}