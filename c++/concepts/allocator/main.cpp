
#include <iostream>
#include <vector>
#include "allocator.h"


// Difference between malloc and new
// malloc: allocate memory without calling constructors (allocation without construction)
// malloc: output of malloc() is a void pointer which should be explicitly casted to corresponding pointer
// new: allocate memory and calling constructors (allocation and construction)

// Difference between free and delete
// free: deallocate memory without calling destructors (deallocation without destruction)
// delete: deallocate memory and calling destructors (deallocation and destruction)

// alignedof: the number of bytes between successive addresses at which objects of this type can be allocated. 
// alignment: requirement, which is a nonnegative integer value (of type std::size_t, and always a power of two)
// representing the number of bytes between successive addresses at which objects of this type can be allocated. 

// Allocation from data memory
unsigned char globalMemPtr[8];

// class example
class B{

    public:

    B():B(1,2,3){}
    B(int a, int b, int c):x(a), y(b), z(c){}

    int x;
    int y;
    int z;
};

int main()
{
   // Construction of objects in data memory
   auto objPtrOnData1 = new((void*)globalMemPtr) int(5);
   auto objPtrOnData2 = new((void*)globalMemPtr+4) int(6);

   // Allocation from stack memory
   unsigned char stackMemPtr[8];

   // Construction of objects in stack memory
   auto objPtrOnStack1 = new((void*)stackMemPtr) int(5);
   auto objPtrOnStack2 = new((void*)stackMemPtr+4) int(6);

   // Allocation from heap memory
   auto heapMemPtr = new unsigned char[10];

   // Construction of objects in heap memory
   auto objPtrOnHeap1 = new((void*)heapMemPtr) int(5);
   auto objPtrOnHeap2 = new((void*)heapMemPtr+4) int(6);


   // It exceeds the allocated data memory but no error or warning is generated by compiler but it is of course dangerous 
   auto objPtrOnData3 = new((void*)globalMemPtr+8) int(7);
   // It leads to the error "stack smashing detected" because it exceeds the allocated stack memory and causes "buffer overflow", which can 
   // overwrite the return address of main function  
   auto objPtrOnStack3 = new((void*)stackMemPtr+8) int(7);
   // It exceeds the allocated heap memory but no error or warning is generated by compiler but it is of course dangerous 
   auto objPtrOnHeap3 = new((void*)heapMemPtr+8) int(7);


   std::cout<<"..........global memory..........."<<std::endl;

   std::cout<<*objPtrOnData1<<std::endl;
   std::cout<<*objPtrOnData2<<std::endl;
   std::cout<<*objPtrOnData3<<std::endl;

   std::cout<<"..........stack memory..........."<<std::endl;

   std::cout<<*objPtrOnStack1<<std::endl;
   std::cout<<*objPtrOnStack2<<std::endl;
   std::cout<<*objPtrOnStack3<<std::endl;

   std::cout<<"..........heap memory..........."<<std::endl;

   std::cout<<*objPtrOnHeap1<<std::endl;
   std::cout<<*objPtrOnHeap2<<std::endl;
   std::cout<<*objPtrOnHeap3<<std::endl;

    std::cout<<".............vector with custom memory allocation..........."<<std::endl;

   // Use a custom allocator for allocation and deallocation of std::vector
   std::vector<int, allocator<int>> vec;
   vec.push_back(30);
   vec.push_back(40);
   vec.push_back(50);


   std::cout<<".............Test and understand allocator..................."<<std::endl;

   // Test
   allocator<B> allocator1;
   // reserves a block of memory
   auto startMem = allocator1.allocate(10);
   // constructs an object at the position of "startMem+5" of "B" with passing three arguments
   allocator1.construct(startMem+5, 10,20,30);
   // Checks if the object is constructed at the position "startMem+5"
   std::cout<<(startMem+5)->x<<"\n";
   std::cout<<(startMem+5)->y<<"\n";
   std::cout<<(startMem+5)->z<<"\n";
   // destructs an object at the position of "startMem+5"
   allocator1.destroy(startMem+5);
   // free the reserved block of memory
   allocator1.deallocate(startMem, 10);


   return 0;
}